## 문제

N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.

N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N이 주어진다. (1 ≤ N < 15)

```java
N개의 행에 대해서
중복을 허락해서 N개의 퀸을 각각의 열에 순서대로 나열하는 경우의 수

1. 시간복잡도
- O(N^M)
- 14^14 > 10^16
- 최대 연산횟수가 1억을 넘어가는 것을 알 수 있다.
- 기존의 완전탐색보다 좀 더 개선된 방법이 필요하다. 
```

## 출력

첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.

## 예제 입력 1

```
8

```

## 예제 출력 1

```
92
```

## Solutions

### Solution1.

기존의 완전탐색으로 구현한 경우, **불필요한 탐색을 굉장히 많이 하기 때문에 시간초과가 발생**하게 된다.

```java
static void rec_func(int row) {
	if (row == N + 1) {
			if (validity_check()) { //서로 공격하는 퀸이 없는 경우
					ans++;
			}
	} else {
			for(int c = 1; c <= N; c++) {
					col[row] = c;
					rec_func(row + 1);
					col[row] = 0;
			}
	}
}
```

### Solution2.

불필요한 탐색을 줄이기 위해서 매 행의 퀸을 배치할 열을 선택할 때마다 이전 퀸의 공격범위에 들어가지 않는 지 확인하는 작업을 진행한다.

만약, 공격범위라면 경우에 포함시키지 않고, 공격범위가 아니라면 경우에 포함시킨 뒤, 다음 재귀함수 호출을 함다.

```java
static void rec_func(int row) {
	if (row == N + 1) {
			//row == N + 1이라는 것만으로도 성공적으로 퀸을 배치했다는 것을 의미함으로
			ans++;
	} else {
			for(int c = 1; c <= N; c++) {
					// 공격범위에 들어가는가
					boolean possible = true;
					for(int i = 1; i <= row - 1; i++) {
							if (attakable(row, c, i, col[i]))
									possible = false;
					}
					if (possible) {
							col[row] = c;
							rec_func(row + 1);
							col[row] = 0;
					}
			}
	}
}
```

attakable() 함수의 경우, 사선으로 위치해 있을 때는 행 + 열의 값이, 역사선으로 위치해 있을 때는 행 - 열의 값이 동일하다는 점을 이용해서

공격범위에 들어오는 지 확인한다.
