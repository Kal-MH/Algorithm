# 개념

## 동적 프로그래밍

문제의 크기를 변화하면서 정답을 계산해나가는 과정.

작은 문제의 결과를 이용해서 큰 문제의 정답을 빠르게 계산하는 알고리즘.

```java
1. 문제가 원하는 정답을 찾기 위해 가장 먼저 완전 탐색 접근을 시도
2. 근데, 완전 탐색 과정에서 탐색하게 되는 경우가 지나치게 많아서 도저히 안됨을 깨달음.
3. 이럴 때, 모든 경우를 빠르게 탐색하는 방법으로 동적 프로그래밍 접근 시도
- 규격화된 문제 풀이 순서를 외워서 훈련해야 한다.
```

## 순서

1. 풀고 싶은 가짜 문제 정의
    1. 예시는 다음과 같다.
        1. Dy[i] = 1 ~ i번 원소에 대해서 조건을 만족하는 경우의 수
        2. Dy[i][j] = i ~ j번 원소에 대해서 조건을 만족하는 최댓값
        3. Dy[i][j] = 수열 A[1..i]와 수열 B[1...j]에 대해서 무언가를 계산한 값
2. 가짜 문제를 풀면 진짜 문제를 풀 수 있는가
    
    ```java
    진짜 문제
    수열 A[1...N]에서 조건을 만족하는 부분수열의 개수
    
    가짜 문제
    Dy[i] : 수열 A[1...i]에서 조건을 만족하는 부분 수열의 개수
    ```
    
    가짜 문제를 푼다면 Dy[1], ...Dy[N]에 대해 모든 계산이 완료되어 있으므로 Dy[N]이 곧 진짜 문제에서 요구하는 답임을 알 수 있다.
    
3. 초기값은 어떻게 되는가
    1. 가장 작은 문제 해결하기
4. 점화식 구해내기
    1. 가장 작은 문제를 기반으로 점점 더 큰 문제들을 해결하면서 Dy배열을 가득 채우는 과정.
5. 진짜 문제 정답 출력하기
    1. 최종적으로 구한 Dy배열을 이용해 문제 해결하기
