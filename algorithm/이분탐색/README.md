## 개념

수열과 탐색 대상 x가 주어졌다고 하자.

```java
x = 63

72 | 19 | 38 | 58 | 10 | 92 | 18 | 11 | 87 |
```

탐색을 통해 해결하고 싶은 3가지 질문

- x가 존재하는가?
- x [이하, 미만, 이상, 초과]의 원소는 몇 개가 있는가?
- x랑 가장 가까운 원소는 무엇인가

### 이분탐색 O(logN)

**정렬된 배열**을 기준으로 탐색하는 방법으로 정렬 데이터의 특성을 극대화한다. L, R, Result로 전형적인 변수 세팅을 통해 탐색을 진행한다.

→ 위 3가지 질문에 대해서 시간복잡도 O(logN)으로 탐색할 수 있다.

```java
x = 63

10 | 11 | 18 | 19 | 38 | (58) | 72 | 87 | 92 |
```

오름차순으로 정렬된 배열이 있다고 할 때, x 이하의 원소 중에 가장 오른쪽에 있는 원소를 찾는다고 가정해보자.

- M번 인덱스에서 **A[M] > x**라면 A[M...N] 즉, M번 인덱스 이상의 모든 값은 x보다 **크다.**
- M번 인덱스에서 **A[M] < x**라면 A[1...M] 즉, M번 인덱스 이하의 모든 값은 x보다 **작다.**

따라서, 

A[6]은 x이하 값 중에 제일 큰 값(x 이하 원소 중 가장 오른쪽에 있는 값)이고,

A[7]은 x보다 큰 값이며,

x이하의 값을 가지는 원소의 개수는 6개임을 알 수 있다.

### 이분탐색 자주하는 실수

1. **정렬되지 않은 데이터를 사용**
2. L, R, M, Result변수의 정의를 헷갈려 부등호를 잘못 쓰는 경우
3. L, R의 범위 혹은 Result의 초기값을 잘못 설정.

---

## 매개변수 탐색(Parametric search)

### 기본 아이디어

- 배열의 값은 0과 1만 존재하면 오름차순이 보장된다.
- 한 번의 연산에서 O(T)의 시간복잡도를 가질 때, 0과 1의 경계를 찾아야 한다면?
    
    ```java
    ex) Up-Down 게임!
    1. A가 1 ~ 1000 사이 자연수 선택
    2. B가 "생각한 숫자가 x이상이야?" 라고 질문
    3. 맞으면 1, 아니면 0이라고 대답
    4. 최소 질문 횟수는?
    -> 1. 모든 숫자에 대해 "생각한 숫자가 x이상이야? 라고 질문 -> O(T x 1000)
       2. **이분탐색**을 활용하여 정답 가능 구간을 좁혀나간다. -> O(T x log1000) = o(T x 10)
    ```
    

### 풀이 순서

1. **매개변수**를 만들고, **Yes/No문제(결정문제)**로 바꾸기
2. 모든 값에 대해서 Yes/No로 채웠을 때 **정렬된 상태**인지 확인!

<aside>
💡 문제에서 **최댓값, 최솟값**이라는 키워드를 주목해보자!

</aside>

### 자주하는 실수

1. yes/no로 정렬되지 않았는데 이분탐색하는 경우
2. L, R, M, Result 변수 정의를 헷갈려 부등호를 잘못 쓰는 경우
3. L, R의 범위를 잘못 설정하거나 Result의 초기값을 잘못 설정하는 경우
