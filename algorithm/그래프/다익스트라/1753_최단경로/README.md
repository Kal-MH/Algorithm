## 문제

방향그래프가 주어지면 **주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램**을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.

```java
V이 2만, E가 30만으로 제법 큰 편이다. 
정말 단순하게 V*E는 60억으로 시간초과가 발생할 것으로 예상된다.

즉, 적어도 LogN으로 최단경로를 찾을 수 있는 알고리즘을 활용해야하는 문제이다.
모든 목적지를 찾아야 한다는 점에서 플로이드-워셜(Floyd-Warshall)을 떠올릴수도 있으나,

1) 플로이드-워셜은 N이 300 이상에서 시간초과로 불가능하다 (시간복잡도 : N^3)
2) 최소한 출발지가 고정되어있기 때문에 **다익스트라**를 활용해볼 수 있다.

[순서도]
//시간복잡도를 줄이기 위해 우선순위 큐 사용
		
//1. 초기화
// - start 삽입

//2. dequeue
			//	 - target으로 가는 이전 최소경로와 지금 경로의 값 비교
			// 	 - 현재 target에 있다고 생각해보자.
			//		- now에서 target으로 오는 경로가 이전 최소경로보다 더 비싸다고 할 때 해당 경로로 올 필요가 없기 때문에 
			//		- continue를 통해 경로를 스킵하는 것이다.
			//	- **우선순위큐에 들어가는 Edge들은 그 순간의 최소경로이기 때문에 다시 poll을 하는 그 사이에 더 짧은 최소경로가 발견될 수 있다.
			//	- 그럴 경우, enqueue되었던 요소의 최소경로 경로값과 갱신된 새로운 최소경로값 dist[i]를 비교해 
			//		continue를 통해 스킵하게 된다.**
//3. 갈 수 있는 곳 순회 - child
//4. 갈 수 있는가
//	 - 지금 노드를 거쳐서 가는 경로의 값이 이전 경로보다 적으면 갈 수 있다.
//	5. enqueue
```

## 입력

첫째 줄에 **정점의 개수 V**와 **간선의 개수 E**가 주어진다. (1≤V≤20,000, 1≤E≤300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 **시작 정점의 번호 K**(1≤K≤V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. **서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음**에 유의한다.

```java
단, 주의할 점
1) 일반 Queue를 활용하면 시간복잡도가 O(V^2 + E) 이므로 시간초과가 발생
-> PQ를 활용한 다익스트라의 경우 시간 복잡도가 O(ElogV)이므로 통과할 것으로 보인다.

2) 일반적인 다익스트라는 보통 목적지를 정해놓고, 목적지에 도달하면 종료하지만,
이 문제에서는 모든 정점에 대한 최단경로를 출력해야하므로, **PQ가 모두 소진될때까지 수행**해야한다
```

## 출력

첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.

## 예제 입력 1

```
5 6
1
5 1 1
1 2 2
1 3 3
2 3 4
2 4 5
3 4 6

```

## 예제 출력 1

```
0
2
3
7
INF
```
